二叉树：理论上不可能同时将两列都按顺序进行组织

B-Tree(多路平衡查找树)
B-Tree的结构可以让系统高效的找到数据所在的磁盘快
定义一条记录为二元组[key,data],key为记录的主键值，对应表中的主键值，data为一行记录中除主键外的数据。key值互不相同。
所有的key值都是按顺序存储，并且每一个叶子节点到跟的距离相同。
一个节点的key从左到右非递减排列。

一个m阶的B-Tree有如下特性：
（1）每个节点最多有m个孩子,根结点的儿子数[2,m]
（2）除了根结点和叶子节点外，其他每个节点都有k-1个元素和k个孩子，其中[m/2]<=k<=m.
（3）所有叶子节点都在同一层，包含被索引的数据,包含k-1个元素，指针均为null
（4）每个非终端节点包含n个关键字信息。
（5）P(i-1)指向的子树的所有节点关键字均小于ki

内存中的关键字是一个有序表结构，可以利用二分查找提高效率，磁盘I/O是影响查找效率的决定因素。

B-Tree索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要数据，取而代之的是从索引的根结点开始进行搜索。
根节点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下层查找。
通过比较节点页的值和要查找的值可以找到合适的指针进入下层子节点，这些指针实际上定义了子节点页中值的上限和下限。

B树中往返于每个节点之间，意味着在硬盘的页面之间多次访问
当想要遍历所有元素时（中序）会出现访问一个节点多次

B+Tree（B-树的扩充）
出现在分支节点中的元素会被当作他们在该分支节点位置的中序后继者（叶子节点中在此列出）


属性：
(1)所有的叶子节点包含全部关键字的信息，及指向含这些关键字记录的指针
(2)所有的分支节点可以看成是索引，不提供实际记录的访问，只存储key
(3)每一个叶子节点都会保存一个指向后一叶子节点的指针
(4)非叶子结点的子树指针和关键字个数相同

B-树和B+树比较
（1）B+树的磁盘读写代价更低：B+树的内部结点并没有指向关键字具体信息的指针，因此其内部结点相对B树更小。
如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存中
的需要查找的关键字也越多，相对来说I/O读写次数降低了
（2）B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引，所以
任何关键字的查找必须走一条从根结点到叶子结点的路，所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

B树详解：https://blog.csdn.net/hao65103940/article/details/89032538
http://blog.codinglabs.org/articles/theory-of-mysql-index.html

红黑树
红黑树是二叉搜索树的一种改进，二叉搜索树在最坏的情况下可能会变成一个链表，
而红黑树在每一次插入或删除结点后都会花O(logN)的时间来对树的结构作修改，以保持树的平衡。

属性：
（1）每个结点包含一个key，parent,lchild,rchild,color
（2）根结点是黑色的
（3）空结点是黑色的（所有结点不指向NULL而是指向一个定义好的空结点）
（4）红色结点所有指针指向黑色结点
（5）任何一颗子树中，每一条从根结点向下走到空结点的路径上包含的黑色结点数量都相同
